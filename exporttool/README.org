#+options: ':nil *:t -:t ::t <:t H:4 \n:nil ^:nil arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil expand-links:t f:t
#+options: inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+options: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+title: README
#+date: <2025-11-27 Thu>
#+author: Gergely Szabo
#+email: gergely.szabo@sap.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 30.2 (Org mode 9.7.27)
#+cite_export:

* Introduction

=xp-clifford= (Crossplane CLI Framework for Resource Data Extraction)
is a Go module that facilitates the development of CLI tools for
exporting definitions of external resources in the format of specific
Crossplane provider managed resource definitions.

TODO:
#+begin_quote
Maybe it makes sense to add a sentence to the introduction, mentioning
that the purpose of the tool is to automate creation of resource
definitions, that are to be imported into Crossplane as per general
import procedure.

https://docs.crossplane.io/v1.20/guides/import-existing-resources/
#+end_quote

* Examples

These examples demonstrate the basic features of =xp-clifford= and
build progressively on one another.

** The simplest CLI tool

The simplest CLI tool you can create using =xp-clifford= looks like
this:

#+name: basic-example
#+begin_src go :noweb yes :tangle examples/basic/main.go :results drawer
package main

<<imports>>

<<basic-main>>
#+end_src

#+RESULTS: basic-example
:results:
test system exporting tool is a CLI tool for exporting existing resources as Crossplane managed resources

Usage:
  test-exporter [command]

Available Commands:
  completion  Generate the autocompletion script for the specified shell
  export      Export test system resources
  help        Help about any command

Flags:
  -c, --config string   Configuration file
  -h, --help            help for test-exporter
  -v, --verbose         Verbose output

Use "test-exporter [command] --help" for more information about a command.
:end:

Let's examine the =import= section.

#+name: imports
#+begin_src go :eval never
import (
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	_ "github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"
)
#+end_src

Two packages must be imported:

- =github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli=
- =github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export=

The =cli/export= package is imported for side effects only.

The =main= function looks like this:

#+name: basic-main
#+begin_src go :eval never
func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	cli.Execute()
}
#+end_src

The =Configuration= variable from the =cli= package is used to set
specific parameters for the built CLI tool. Here we set the =ShortName= and
=ObservedSystem= fields.

These fields have the following meanings:

- ShortName :: The abbreviated name of the observed system without
  spaces, such as "cf" for the CloudFoundry provider
- ObservedSystem :: The full name of the external
  system, which may contain spaces, such as "Cloud Foundry"

At the end of the =main= function, we invoke the
=Execute= function from the =cli= package to start the CLI.

When we run this basic example, it generates the following output:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/basic/main.go
#+end_src

#+RESULTS:
#+begin_example
test system exporting tool is a CLI tool for exporting existing resources as Crossplane managed resources

Usage:
  test-exporter [command]

Available Commands:
  completion  Generate the autocompletion script for the specified shell
  export      Export test system resources
  help        Help about any command

Flags:
  -c, --config string   Configuration file
  -h, --help            help for test-exporter
  -v, --verbose         Verbose output

Use "test-exporter [command] --help" for more information about a command.
#+end_example

If you try running the CLI tool with the export subcommand, you get an
*error* message.

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/basic/main.go export
#+end_src

#+RESULTS:
: ERRO export subcommand is not set

** Exporting
*** Basic export subcommand

The =export= subcommand is mandatory, but you are responsible for implementing the code that executes when it is invoked.

The code must be defined as a function with the following signature:

#+begin_src go :eval never
func(ctx context.Context, events export.EventHandler) error
#+end_src

The =ctx= parameter can be used to handle interruptions, such as when the user presses /Ctrl-C/. In such cases, the =Done()= channel of the context is closed.

The =events= parameter from the =export= package provides three methods for communicating progress to the CLI framework:

- Warn :: Indicates a recoverable error that does not terminate the export operation.
- Resource :: Indicates a processed managed resource to be printed or stored by the export operation.
- Stop :: Indicates that exporting has finished. No more =Warn= or =Resource= calls should be made after =Stop=.

A fatal error can be indicated by returning a non-nil error value.

A simple implementation of an export logic function looks like this:

#+name: simple-export-fn
#+begin_src go :eval never
func exportLogic(_ context.Context, events export.EventHandler) error {
	slog.Info("export command invoked")
	events.Stop()
	return nil
}
#+end_src

This implementation prints a log message, stops the event handler, and returns a =nil= error value.

You can configure the business logic function using the =SetCommand= function from the =export= package:

#+name: configure-exportlogic
#+begin_src go
export.SetCommand(exportLogic)
#+end_src

A complete example is:

#+name: basic-example
#+begin_src go :noweb yes :tangle examples/export/main.go
package main

import (
	"context"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"
)

<<simple-export-fn>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	<<configure-exportlogic>>
	cli.Execute()
}
#+end_src

To invoke the =export= subcommand:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/export/main.go export
#+end_src

#+RESULTS:
: INFO export command invoked

*** Exporting a resource

In the previous example, we created a proper =export= subcommand, but
didn't actually export any resources.

To export a resource, use the =Resource= method of the =EventHandler=
type:

#+begin_src go :eval never
Resource(res resource.Object) // Object interface defined in
                              // github.com/crossplane/crossplane-runtime/pkg/resource
#+end_src

This method accepts a =resource.Object=, an interface implemented by
all Crossplane resources.

Let's update our =exportLogic= function to export a single
resource. For simplicity, we'll use the =Unstructured= type from
=k8s.io/apimachinery/pkg/apis/meta/v1/unstructured=, which implements
the =resource.Object= interface:

#+name: single-export-fn
#+begin_src go :eval never
func exportLogic(_ context.Context, events export.EventHandler) error {
	slog.Info("export command invoked")

	res := &unstructured.Unstructured{
	  Object: map[string]interface{}{
	      "user": "test-user",
	      "password": "secret",
	  },
	}
	events.Resource(res)

	events.Stop()
	return nil
}
#+end_src

The complete example now looks like this:

#+name: single-example
#+begin_src go :noweb yes :tangle examples/exportsingle/main.go
package main

import (
	"context"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

<<single-export-fn>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	<<configure-exportlogic>>
	cli.Execute()
}
#+end_src

Running this example produces the following output:

#+name: ansi-filter
#+begin_src elisp :var data="test" :exports none :eval yes
(ansi-color-filter-apply data)
#+end_src

#+begin_src sh :exports both :results output :eval no-export :post ansi-filter(data=*this*)
go run ./examples/exportsingle/main.go export
#+end_src

#+RESULTS:
: INFO export command invoked
:
:
:     ---
:     password: secret
:     user: test-user
:     ...
:

The exported resource is printed to the console. You can redirect the
output to a file using the =-o= flag:

#+begin_src sh :exports both :results output :eval no-export :post ansi-filter(data=*this*)
go run ./examples/exportsingle/main.go export -o output.yaml
#+end_src

#+RESULTS:
: INFO export command invoked
: INFO Writing output to file output=output.yaml

The =output.yaml= file contains the exported resource object:

#+begin_src sh :exports both :results output :eval no-export :post ansi-filter(data=*this*)
cat output.yaml
#+end_src

#+RESULTS:
: ---
: password: secret
: user: test-user
: ...

*** Displaying warnings

During the processing and conversion of external resources, the export
logic may encounter unexpected situations such as unstable network
connections, authentication issues, or unknown resource
configurations.

These events should not halt the resource export process, but they
must be reported to the user.

You can report warnings using the =Warn= method of the =EventHandler=
type:

#+begin_src go :eval never
Warn(err error)
#+end_src

The =Warn= method supports =erratt.Error= types. The =erratt.Error=
type is demonstrated in [[#erratt-example]].

Let's add a warning message to our =exportLogic= function:

#+name: warn-export-fn
#+begin_src go :eval never
func exportLogic(_ context.Context, events export.EventHandler) error {
	slog.Info("export command invoked")

	events.Warn(errors.New("generating test resource"))

	res := &unstructured.Unstructured{
	  Object: map[string]interface{}{
	      "user": "test-user-with-warning",
	      "password": "secret",
	  },
	}
	events.Resource(res)

	events.Stop()
	return nil
}
#+end_src

The complete example now looks like this:

#+name: warn-example
#+begin_src go :noweb yes :tangle examples/exportwarn/main.go
package main

import (
	"context"
	"errors"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

<<warn-export-fn>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	<<configure-exportlogic>>
	cli.Execute()
}
#+end_src

Running this example displays the warning message in the logs:

#+begin_src sh :exports both :results output :eval no-export :post ansi-filter(data=*this*)
go run ./examples/exportwarn/main.go export
#+end_src

#+RESULTS:
: INFO export command invoked
: WARN generating test resource
:
:
:     ---
:     password: secret
:     user: test-user-with-warning
:     ...
:

When redirecting the output to a file, the warning appears on screen
but not in the file:

#+begin_src sh :exports both :results output :eval no-export :post ansi-filter(data=*this*)
go run ./examples/exportwarn/main.go export -o output.yaml
#+end_src

#+RESULTS:
: INFO export command invoked
: WARN generating test resource
: INFO Writing output to file output=output.yaml

#+begin_src sh :exports both :results output :eval no-export :post ansi-filter(data=*this*)
cat output.yaml
#+end_src

#+RESULTS:
: ---
: password: secret
: user: test-user-with-warning
: ...

*** Exporting commented out resources

During the export process, problems may prevent generation of valid
managed resource definitions, or the definitions produced may be
unsafe to apply.

You have two options for handling problematic resources: omit them
from the output entirely, or include them but commented
out. Commenting out invalid or unsafe resource definitions ensures
users won't encounter problems when applying the export tool output.

=xp-clifford= comments out resources that implement the
=yaml.CommentedYAML= interface, which defines a single method:

#+begin_src go :eval never
type CommentedYAML interface {
	Comment() (string, bool)
}
#+end_src

The =bool= return value indicates whether the managed resource should
be commented out. The =string= return value provides a message that
will be printed as part of the comment.

Since Crossplane managed resources don't typically implement the
=CommentedYAML= interface, you can wrap them to add this
functionality.

The =yaml.NewResourceWithComment= function handles this wrapping for
you:

#+begin_src go :eval never
func NewResourceWithComment(res resource.Object) *yaml.ResourceWithComment
#+end_src

The =*yaml.ResourceWithComment= type wraps =res= and implements the
=yaml.CommentedYAML= interface. It also provides helper methods:

- SetComment :: sets the comment string
- AddComment :: appends to the comment string

The following example demonstrates the commenting feature:

#+name: comment-export-fn
#+begin_src go :eval never
func exportLogic(_ context.Context, events export.EventHandler) error {
	slog.Info("export command invoked")

	res := &unstructured.Unstructured{
	  Object: map[string]interface{}{
	      "user": "test-user-commented",
	      "password": "secret",
	  },
	}

	commentedResource := yaml.NewResourceWithComment(res)
	commentedResource.SetComment("don't deploy it, this is a test resource!")
	events.Resource(commentedResource)

	events.Stop()
	return nil
}
#+end_src

Here is the complete example:

#+name: warn-example
#+begin_src go :noweb yes :tangle examples/exportcomment/main.go
package main

import (
	"context"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/yaml"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

<<comment-export-fn>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	<<configure-exportlogic>>
	cli.Execute()
}
#+end_src

Running this example displays the commented resource with its comment
message:

#+begin_src sh :exports both :results output :eval no-export :post ansi-filter(data=*this*)
go run ./examples/exportcomment/main.go export
#+end_src

#+RESULTS:
#+begin_example
INFO export command invoked


    #
    # don't deploy it, this is a test resource!
    #
    # ---
    # Object:
    #   password: secret
    #   user: test-user-commented
    # ...

#+end_example

This works equally well when redirecting output to a file using the
=-o= flag.

** Errors with attributes
:PROPERTIES:
:CUSTOM_ID: erratt-example
:END:

The =erratt= package implements a new =error= type designed for
efficient use with the =Warn= method of =EventHandler=.

The =erratt.Error= type implements the standard Go =error=
interface. Additionally, it can be extended with =slog= package
compatible key-value pairs used for structured logging. The
=erratt.Error= type also supports wrapping Go =error= values. When an
=erratt.Error= is wrapped, its attributes are preserved.

You can create a simple =erratt.Error= using the =erratt.New=
function:

#+begin_src go :eval never
err := erratt.New("something went wrong")
errWithAttrs1 := erratt.New("error opening file", "filename", filename)
errWithAttrs2 := erratt.New("authentication failed", "username", user, "password", pass)
#+end_src

In this example, =errWithAttrs1= and =errWithAttrs2= include
additional attributes.

You can wrap an existing =error= value using the =erratt.Errorf=
function:

#+begin_src go :eval never
err := callFunction()
errWrapped := erratt.Errorf("unexpected error occurred: %w", err)
#+end_src

You can extend an =erratt.Error= value with attributes using the
=With= method:

#+begin_src go :eval never
err := connectToServer(url, username, password)
errWrapped := erratt.Errorf("cannot connect to server: %w", err).
	With("url", url, "username", username, "password", password)
#+end_src

For a complete example, consider two functions that return
=erratt.Error= values and demonstrate wrapping:

#+name: erratt-error-return-func
#+begin_src go :eval never
func auth() erratt.Error {
	return erratt.New("authentication failure",
		"username", "test-user",
		"password", "test-password",
	)
}

func connect() erratt.Error {
	err := auth()
	if err != nil {
		return erratt.Errorf("connect failed: %w", err).
			With("url", "https://example.com")
	}
	return nil
}
#+end_src

The =auth= function returns an =erratt.Error= value with username and
password attributes.

The =exportLogic= function calls =connect= and handles the error:

#+name: erratt-exportlogic
#+begin_src go :eval never
func exportLogic(_ context.Context, events export.EventHandler) error {
	slog.Info("export command invoked")

	err := connect()

	events.Stop()
	return err
}
#+end_src

Here is the complete example:

#+name: erratt-example
#+begin_src go :noweb yes :tangle examples/erratt/main.go :eval never
package main

import (
	"context"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/erratt"
)

<<erratt-error-return-func>>

<<erratt-exportlogic>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	<<configure-exportlogic>>
	cli.Execute()
}
#+end_src

Running this code produces the following output:

#+begin_src sh :exports both :results output :eval no-export :post ansi-filter(data=*this*)
go run ./examples/erratt/main.go export
#+end_src

#+RESULTS:
: INFO export command invoked
: ERRO connect failed: authentication failure url=https://example.com username=test-user password=test-password

The error message appears on the console with all attributes
displayed.

The =EventHandler.Warn= method handles =erratt.Error= values in the
same manner.

** Widgets

=xp-clifford= provides several CLI widgets to facility the interaction
with the user.

*** TextInput widget

The TextInput widget prompts the user for a single line of
text. Create a TextInput widget using the =TextInput= function from
the =widget= package.

#+begin_src go :eval never
func TextInput(ctx context.Context, title, placeholder string, sensitive bool) (string, error)
#+end_src

Parameters:

- ctx :: Go context for handling Ctrl-C interrupts or timeouts
- title :: The prompt question displayed to the user
- placeholder :: Placeholder text shown when the input is empty
- sensitive :: When true, masks typed characters (useful for passwords)

The following example demonstrates an =exportLogic= function that
prompts for a username and password:

#+name: textinput-username
#+begin_src go :eval never
func exportLogic(ctx context.Context, events export.EventHandler) error {
	slog.Info("export command invoked")

	username, err := widget.TextInput(ctx, "Username", "anonymous", false)
	if err != nil {
		return err
	}

	password, err := widget.TextInput(ctx, "Password", "", true)
	if err != nil {
		return err
	}

	slog.Info("data acquired",
		"username", username,
		"password", password,
	)

	events.Stop()
	return err
}
#+end_src

Complete example:

#+name: textinput-example
#+begin_src go :noweb yes :tangle examples/textinput/main.go :eval never
package main

import (
	"context"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/widget"
)

<<textinput-username>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	<<configure-exportlogic>>
	cli.Execute()
}
#+end_src

See the example in action:

#+caption: TextInput example
[[file:examples/textinput/example.gif]]

*** MultiInput widget

The MultiInput widget creates a multi-selection interface that allows users to select multiple items from a predefined list of options:

#+begin_src go :eval never
func MultiInput(ctx context.Context, title string, options []string) ([]string, error)
#+end_src

Parameters:

- ctx :: Go context for handling Ctrl-C interrupts or timeouts
- title :: The selection prompt displayed to the user
- options :: The list of selectable items

The following example demonstrates an =exportLogic= function that uses the =MultiInput= widget:

#+name: multiinput-example
#+begin_src go :eval never
func exportLogic(ctx context.Context, events export.EventHandler) error {
	slog.Info("export command invoked")

	protocols, err := widget.MultiInput(ctx,
		"Select the supported protocols",
		[]string{
			"FTP",
			"HTTP",
			"HTTPS",
			"SFTP",
			"SSH",
		},
	)

	slog.Info("data acquired",
		"protocols", protocols,
	)

	events.Stop()
	return err
}
#+end_src

The complete source code is assembled as follows:

#+name: multiinput-example
#+begin_src go :noweb yes :tangle examples/multiinput/main.go :eval never
package main

import (
	"context"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/widget"
)

<<multiinput-example>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	<<configure-exportlogic>>
	cli.Execute()
}
#+end_src

Running this example produces the following output:

#+caption: MultiInput example
[[file:examples/multiinput/example.gif]]

** Configuration parameters

CLI tools built using =xp-clifford= can be configured through several
methods:

- Command-line flags
- Environment variables
- Configuration files

=xp-clifford= provides types and functions to facilitate configuration
and management of these parameters. Configuration parameter handling
is also integrated with the widget capabilities of =xp-clifford=.

Currently, the following configuration parameter types are supported:

- =bool=
- =string=
- =[]string=

All configuration parameters managed by =xp-clifford= implement the
=configparam.ConfigParam= interface.

*** Global configuration parameters

Any CLI tool built using =xp-clifford= includes the following global flags:

- =-c= or =--config= :: Configuration file for setting additional
  parameters (string)
- =-v= or =--verbose= :: Enable verbose logging (bool)
- =-h= or =--help= :: Print help message (bool)

**** Verbose logging

Enable verbose logging with the =-v= or =--verbose= flag. When
enabled, structured log messages at the /Debug/ level are also printed
to the console.

An example =exportLogic= function:

#+name: verbose-export-fn
#+begin_src go :eval never
func exportLogic(_ context.Context, events export.EventHandler) error {
	slog.Debug("export command invoked")
	events.Stop()
	return nil
}
#+end_src

The complete example:

#+name: basic-example
#+begin_src go :noweb yes :tangle examples/verbose/main.go
package main

import (
	"context"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"
)

<<verbose-export-fn>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	<<configure-exportlogic>>
	cli.Execute()
}
#+end_src

Executing the =export= subcommand without the =-v= flag produces no
output:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/verbose/main.go export
#+end_src

#+RESULTS:

With the =-v= flag, the debug-level message appears:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/verbose/main.go export -v
#+end_src

#+RESULTS:
: DEBU export command invoked

*** Configuration parameters of the export subcommand

The =export= subcommand includes the following default configuration
parameters:

- =-k= or =--kind= :: Resource kinds to export ([]string)
- =-o= or =--output= :: Redirect output to a file (string)

You can extend the =export= subcommand with additional configuration
parameters using the =export.AddConfigParams= function:

#+begin_src go :eval never
func AddConfigParams(param ...configparam.ConfigParam)
#+end_src

*** Bool configuration parameter

Create a new /bool/ configuration parameter using the =configparam.Bool= function:

#+begin_src go :eval never
func Bool(name, description string) *BoolParam
#+end_src

The two mandatory arguments are /name/ and /description/. Fine-tune
the parameter with these methods:

- =WithShortName= :: Single-character short command-line flag
- =WithFlagName= :: Long format of the command-line flag (defaults to
  /name/)
- =WithEnvVarName= :: Environment variable name for the parameter
- =WithDefaultValue= :: Default value of the parameter

Use the =Value()= method to retrieve the parameter value. The
=IsSet()= method returns true if the user has explicitly set the
value.

Here is a bool configuration parameter definition:

#+name: configure-bool-def
#+begin_src go :eval never
var testParam = configparam.Bool("test", "test bool parameter").
        WithShortName("t").
        WithEnvVarName("CLIFFORD_TEST")
#+end_src

Add the parameter to the =export= subcommand:

#+name: add-bool-def
#+begin_src go :eval never
export.AddConfigParams(testParam)
#+end_src

A complete working example:

#+begin_src go :noweb yes :tangle examples/boolparam/main.go
package main

import (
	"context"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/configparam"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"
)

func exportLogic(_ context.Context, events export.EventHandler) error {
	slog.Info("export command invoked", "test-value", testParam.Value())
	events.Stop()
	return nil
}

<<configure-bool-def>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	<<add-bool-def>>
	<<configure-exportlogic>>
	cli.Execute()
}
#+end_src

The new parameter appears in the help output:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/boolparam/main.go export --help
#+end_src

#+RESULTS:
#+begin_example
Export test system resources and transform them into managed resources that the Crossplane provider can consume

Usage:
  test-exporter export [flags]

Flags:
  -h, --help            help for export
  -k, --kind strings    Resource kinds to export
  -o, --output string   redirect the YAML output to a file
  -t, --test            test bool parameter

Global Flags:
  -c, --config string   Configuration file
  -v, --verbose         Verbose output
#+end_example

By default, test is =false=:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/boolparam/main.go export
#+end_src

#+RESULTS:
: INFO export command invoked test-value=false

Enable it using the =--test= flag:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/boolparam/main.go export --test
#+end_src

#+RESULTS:
: INFO export command invoked test-value=true

Or using the shorthand =-t= flag:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/boolparam/main.go export -t
#+end_src

#+RESULTS:
: INFO export command invoked test-value=true

Or using the =CLIFFORD_TEST= environment variable:

#+begin_src sh :exports both :results output :eval no-export
CLIFFORD_TEST=1 go run ./examples/boolparam/main.go export
#+end_src

#+RESULTS:
: INFO export command invoked test-value=true

*** String configuration parameter

Create a new /string/ configuration parameter using the
=configparam.String= function:

#+begin_src go :eval never
func String(name, description string) *StringParam
#+end_src

The two mandatory arguments are /name/ and /description/. Fine-tune
the parameter with these methods:

- =WithShortName= :: Single-character short command-line flag
- =WithFlagName= :: Long format of the command-line flag (defaults to /name/)
- =WithEnvVarName= :: Environment variable name for the parameter
- =WithDefaultValue= :: Default value of the parameter

Use the =Value()= method to retrieve the parameter value. The
=IsSet()= method returns true if the user has explicitly set the
value.

The =ValueOrAsk= method returns the value if set. Otherwise, it
prompts for the value interactively using the =TextInput= widget.

Consider the following string configuration parameter:

#+name: configure-string-def
#+begin_src go :eval never
var testParam = configparam.String("username", "username used for authentication").
        WithShortName("u").
        WithEnvVarName("USERNAME").
	WithDefaultValue("testuser")
#+end_src

A complete example:

#+begin_src go :noweb yes :tangle examples/stringparam/main.go
package main

import (
	"context"
	"log/slog"

	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/configparam"
	"github.com/SAP/crossplane-provider-cloudfoundry/exporttool/cli/export"
)

func exportLogic(ctx context.Context, events export.EventHandler) error {
	slog.Info("export command invoked",
		"username", testParam.Value(),
		"is-set", testParam.IsSet(),
	)

	// If not set, ask the value
	username, err := testParam.ValueOrAsk(ctx)
	if err != nil {
		return err
	}

	slog.Info("value set by user", "value", username)

	events.Stop()
	return nil
}

<<configure-string-def>>

func main() {
	cli.Configuration.ShortName = "test"
	cli.Configuration.ObservedSystem = "test system"
	export.AddConfigParams(testParam)
	<<configure-exportlogic>>
        cli.Execute()
}
#+end_src

The new parameter appears in the help output:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/stringparam/main.go export --help
#+end_src

#+RESULTS:
#+begin_example
Export test system resources and transform them into managed resources that the Crossplane provider can consume

Usage:
  test-exporter export [flags]

Flags:
  -h, --help              help for export
  -k, --kind strings      Resource kinds to export
  -o, --output string     redirect the YAML output to a file
  -u, --username string   username used for authentication

Global Flags:
  -c, --config string   Configuration file
  -v, --verbose         Verbose output
#+end_example

Set the value using the =--username= flag:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/stringparam/main.go export --username anonymous
#+end_src

#+RESULTS:
: INFO export command invoked username=anonymous is-set=true
: INFO value set by user value=anonymous

Or using the shorthand =-u= flag:

#+begin_src sh :exports both :results output :eval no-export
go run ./examples/stringparam/main.go export -u anonymous
#+end_src

#+RESULTS:
: INFO export command invoked username=anonymous is-set=true
: INFO value set by user value=anonymous

Or using the =USERNAME= environment variable:

#+begin_src sh :exports both :results output :eval no-export
USERNAME=anonymous go run ./examples/stringparam/main.go export
#+end_src

#+RESULTS:
: INFO export command invoked username=anonymous is-set=true
: INFO value set by user value=anonymous

When no value is provided, the =TextInput= widget prompts for it
interactively:

#+caption: Asking a string config parameter value
[[file:examples/stringparam/example.gif]]
